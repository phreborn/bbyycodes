/*note that
T.SetBranchStatus("*",0); //disable all branches
T.SetBranchStatus("c",1);
T.setBranchStatus("e",1);
T.GetEntry(i);
*/

//root -b
//.x 2_Create_rel_effect.C

using namespace std;

string string_path="/sps/atlas/e/escalier/ATLAS_HGam/";

string string_rel_path="Outputs_syst_yield_shape/trees_and_hist/Theory/";

/*shit
string string_rel_path_yield="Outputs_syst_yield_shape/";
string string_rel_path_shape="Outputs_syst_yield_shape/";
*/

string string_prefix_tree="tree_sel_";
vector<string> vec_string_category;

vector<string> vec_files={
  "h026_mc16a_PowhegH7_HHbbyy_cHHH01d0_nominal.root"
  "h026_mc16d_PowhegH7_HHbbyy_cHHH01d0_nominal.root",
  "h026_mc16e_PowhegH7_HHbbyy_cHHH01d0_nominal.root"
  
  /*
  "h026_mc16a_PowhegH7_HHbbyy_cHHH10d0_nominal.root",
  "h026_mc16d_PowhegH7_HHbbyy_cHHH10d0_nominal.root",
  "h026_mc16e_PowhegH7_HHbbyy_cHHH10d0_nominal.root"
  */

  /*
  "h026_mc16a_PowhegPy8_NNLOPS_ggH125_PhotonSys.root",
  "h026_mc16d_PowhegPy8_NNLOPS_ggH125_PhotonSys.root",
  "h026_mc16e_PowhegPy8_NNLOPS_ggH125_PhotonSys.root"
  */

  /*
    "h025_mc16a_PowhegH7_HHbbyy_cHHH01d0_nominal.root",
    
    "h025_mc16d_PowhegH7_HHbbyy_cHHH01d0_nominal.root",
    
    "h025_mc16e_PowhegH7_HHbbyy_cHHH01d0_nominal.root",
    
    "h025_mc16a_PowhegH7_HHbbyy_cHHH10d0_nominal.root",
    
    "h025_mc16d_PowhegH7_HHbbyy_cHHH10d0_nominal.root",
    
    "h025_mc16e_PowhegH7_HHbbyy_cHHH10d0_nominal.root",
    
    //no theoretical effect
    //"h025_mc16a_MGH7_hh_bbyy_vbf_l1cvv1cv1_nominal.root",
    //"h025_mc16d_MGH7_hh_bbyy_vbf_l1cvv1cv1_nominal.root",
    //"h025_mc16e_MGH7_hh_bbyy_vbf_l1cvv1cv1_nominal.root",
    
    "h025_mc16a_PowhegPy8_NNLOPS_ggH125_PhotonSys.root",
    
    "h025_mc16d_PowhegPy8_NNLOPS_ggH125_PhotonSys.root",
    
    "h025_mc16e_PowhegPy8_NNLOPS_ggH125_PhotonSys.root",
    
    "h025_mc16a_PowhegPy8_ZH125J_PhotonSys.root",
    
    "h025_mc16d_PowhegPy8_ZH125J_PhotonSys.root",
    "h025_mc16e_PowhegPy8_ZH125J_PhotonSys.root",
    "h025_mc16a_PowhegPy8_ggZH125_PhotonSys.root",
    "h025_mc16d_PowhegPy8_ggZH125_PhotonSys.root",
    "h025_mc16e_PowhegPy8_ggZH125_PhotonSys.root",
    "h025_mc16a_PowhegPy8_ttH125_fixweight_PhotonSys.root",
    "h025_mc16d_PowhegPy8_ttH125_fixweight_PhotonSys.root",
    "h025_mc16e_PowhegPy8_ttH125_fixweight_PhotonSys.root"
  */
};


/*old approach : to delete once stable
vector<string> vec_files={
  "tree_h025_mc16a_nominal_PowhegH7_HHbbyy_cHHH01d0.root",
  "tree_h025_mc16d_nominal_PowhegH7_HHbbyy_cHHH01d0.root",
  
  "tree_h025_mc16e_nominal_PowhegH7_HHbbyy_cHHH01d0.root",
  
  "tree_h025_mc16a_nominal_PowhegH7_HHbbyy_cHHH10d0.root",
  
  "tree_h025_mc16d_nominal_PowhegH7_HHbbyy_cHHH10d0.root",
  
  "tree_h025_mc16e_nominal_PowhegH7_HHbbyy_cHHH10d0.root",
  
  //no theoretical effect
  //"tree_h025_mc16a_nominal_MGH7_hh_bbyy_vbf_l1cvv1cv1.root",
  //"tree_h025_mc16d_nominal_MGH7_hh_bbyy_vbf_l1cvv1cv1.root",
  //"tree_h025_mc16e_nominal_MGH7_hh_bbyy_vbf_l1cvv1cv1.root",
  
  "tree_h025_mc16a_PhotonSys_PowhegPy8_NNLOPS_ggH125.root",
  
  "tree_h025_mc16d_PhotonSys_PowhegPy8_NNLOPS_ggH125.root",
  
  "tree_h025_mc16e_PhotonSys_PowhegPy8_NNLOPS_ggH125.root",
  
  "tree_h025_mc16a_PhotonSys_PowhegPy8_ZH125J.root",
  
  "tree_h025_mc16d_PhotonSys_PowhegPy8_ZH125J.root",
  "tree_h025_mc16e_PhotonSys_PowhegPy8_ZH125J.root",
  "tree_h025_mc16a_PhotonSys_PowhegPy8_ggZH125.root",
  "tree_h025_mc16d_PhotonSys_PowhegPy8_ggZH125.root",
  "tree_h025_mc16e_PhotonSys_PowhegPy8_ggZH125.root",
  "tree_h025_mc16a_PhotonSys_PowhegPy8_ttH125_fixweight.root",
  "tree_h025_mc16d_PhotonSys_PowhegPy8_ttH125_fixweight.root",
  "tree_h025_mc16e_PhotonSys_PowhegPy8_ttH125_fixweight.root"
  
};
*/


//for potential categories
vector<int> vec_mX_th_systematics={260,280,300,325,350,400,450,500,550,600,700,800,900,1000};

pair<double,double> return_nb_sel(TTree *tree);

double get_err_rel_effect_yield_fully_correlated(double yield_nominal,
						 double yield_sys,
						 double err_yield_nominal,
						 double err_yield_sys);
//=====================================================================================================================================================
int _2_Create_rel_effect()
{

  cout << "vec_files[0]=" << vec_files[0] << endl;
  exit(1);
						    
  for (int index_file=0;index_file<vec_files.size();index_file++) {
    cout << "==================================================================" << endl;

    string string_file_raw=vec_files[index_file];

    string string_file="";

    //no more useful    string prefix_file="tree_";

    /*not useful if ok
    
    //potential affixe in the file name : to ignore for the rel_effect names
    string string_nominal="_nominal";
    string string_PhotonSys="_PhotonSys";


    size_t position_affixe_nominal=string_file_raw.find("nominal");
    size_t position_affixe_PhotonSys=string_file_raw.find("PhotonSys");
    
    cout << "position_affixe_nominal=" << position_affixe_nominal << endl;
    cout << "position_affixe_PhotonSys=" << position_affixe_PhotonSys << endl;

    cout << "string::npos=" << string::npos << endl;
    */
    
    /* obsolete
    for (int index_string_file=0;index_string_file<string_file_raw.size();index_string_file++) {
      
      //old approach, remove if stable
      //       if (index_string_file<prefix_file.size())
      // 	continue;
      
      

      if (
	  (position_affixe_nominal!=string::npos && index_string_file>=position_affixe_nominal && index_string_file<position_affixe_nominal+string_nominal.size())
	  ||
	  (position_affixe_PhotonSys!=string::npos && index_string_file>=position_affixe_PhotonSys && index_string_file<position_affixe_PhotonSys+string_PhotonSys.size())
	  )
	continue;
      
      string_file+=string_file_raw.at(index_string_file);
      
    } //end loop on character of file
    */

    string_file+=string_file_raw;


    cout << "string_file=" << string_file << endl;


    size_t position_string_root=0;
    
    position_string_root=string_file.find(".root");
    
    if (position_string_root==string::npos) {
      cout << "problem, didn't found the root suffix, halt program" << endl;
      exit(1);
    }


    /*
    //shit if stable
    string string_sample=string_file.substr(0,position_string_root);
    cout << "string_sample=" << string_sample << endl;
    exit(1);
    */

    //----------------------------------------------------------------------------------------------
    //creation of categories

    vec_string_category.clear();

    //TO DO A FUNCTION    
    //HH non resonant baseline
    if (string_file.find("_X")==string::npos) { //sample is not a resonant sample, so either a HH non resonant or a single Higgs
      
      //so consider to include the non resonant categories
      
      //      vec_string_category.push_back("Inclusive_HH_NonResonant");
      vec_string_category.push_back("XGBoost_btag77_withTop_BCal_tightScore_HMass");
      vec_string_category.push_back("XGBoost_btag77_withTop_BCal_looseScore_HMass");
      vec_string_category.push_back("XGBoost_btag77_withTop_BCal_tightScore_LMass");
      vec_string_category.push_back("XGBoost_btag77_withTop_BCal_looseScore_LMass");
      //      vec_string_category.push_back("VBF_btag77_withTop_BCal");
    }
    
    //HH resonant baseline
    
    if (string_file.find("_HHH")==string::npos
	&&
	string_file.find("bbyy_vbf_")==string::npos
	) { //sample is not a non-resonant sample, so either a HH resonant or a single Higgs
      
      //so consider to include the resonant categories
    
      bool is_single_Higgs=0;
      if (string_file.find("ggH125")!=string::npos
	  ||
	  string_file.find("ZH125")!=string::npos
	  ||
	  string_file.find("ttH125")!=string::npos
	  )
	is_single_Higgs=1;
      
      for (unsigned int index_mX=0;index_mX<vec_mX_th_systematics.size();index_mX++) {
	
	string string_resonance="X"+to_string(vec_mX_th_systematics[index_mX]);
	cout << "string_resonance=" << string_resonance << endl;
	
	cout << "string_file=" << string_file << endl;

	if (
	    is_single_Higgs //is not a resonant sample
	    ||
	    (string_file.find("MGH7_X")!=string::npos && string_file.find(string_resonance)!=string::npos) //is the resonant sample of the corresponding mX
	    ) {
	  //	  vec_string_category.push_back("Resonant_mX"+to_string(vec_mX_th_systematics[index_mX]));
	  cout << "adding category Resonant_mX"+to_string(vec_mX_th_systematics[index_mX]) << endl;
	}

      } //end loop on mX
    } //end case resonant

    for (int index_category=0;index_category<vec_string_category.size();index_category++)
      cout << "index_category=" << index_category << ", " << vec_string_category[index_category] << endl;
   
    //----------------------------------------------------------------------------------------------
    
    cout << "index_file=" << index_file << " / " << vec_files.size() << endl;

    //shit    TFile *f_source=TFile::Open((string_path+string_rel_path_shape+"trees_and_hist/Theory/"+vec_files[index_file]).c_str(),"update");
    TFile *f_source=TFile::Open((string_path+string_rel_path+vec_files[index_file]).c_str(),"update");
    
    cout << "(string_path+string_rel_path+vec_files[index_file])=" << (string_path+string_rel_path+vec_files[index_file]) << endl;
    exit(1);
    f_source->cd();

    TList *list=f_source->GetListOfKeys();

    int nb_keys=list->GetEntries();
    
    for (int index_category=0;index_category<vec_string_category.size();index_category++) {
      
      string string_category=vec_string_category[index_category];

      pair<double,double> pair_nb_sel_nominal;
      pair<double,double> pair_nb_sel_sys;

      bool found_nominal=0;
      
      for (int index_key=0;index_key<nb_keys;index_key++) {
	//cout << "index_key=" << index_key << endl;
	
	TKey *key=(TKey *)list->At(index_key);
	
	if (strcmp(key->GetClassName(),"TTree"))
	  continue;
	
	//this is a TTree at this place
	
	char *name_tree=(char *)key->GetName();
	
	TTree *tree=(TTree *)f_source->Get(name_tree);
	
	//      cout << "tree->GetName()=" << tree->GetName() << endl;
	
	string string_tree=name_tree;
	
	if (string_tree.find(string_category)==string::npos) //ignore if it does not belong to current category
	  continue;
	//----------
	//identify the variation : remove word Inclusive or other word of category
	
	int size_string_prefix_tree=string_prefix_tree.size();
	
	size_t position_string_category=0;
	
	int index_category=0;
	
	position_string_category=string_tree.find(string_category);
	
	if (position_string_category==string::npos) {
	  cout << "problem, didn't found the category, halt program" << endl;
	  exit(1);
	}
	
	position_string_category--; //take into account the "_" before the category
	string string_variation=string_tree.substr(size_string_prefix_tree,position_string_category-size_string_prefix_tree);
	
	cout << "===" << endl;
	cout << "dealing with string_variation=" << string_variation << ", tree=" << name_tree << endl;
	//----------	
	if (string_variation=="nominal") {
	  found_nominal=1;

	  pair_nb_sel_nominal=return_nb_sel(tree);
	}
	else
	  pair_nb_sel_sys=return_nb_sel(tree);
	
	if (found_nominal && string_variation=="nominal") { //write the results
	  string string_hist_nb_sel_nominal="hist_nb_sel_nominal";
	  
	  string_hist_nb_sel_nominal+="_";
	  string_hist_nb_sel_nominal+=string_category;
	  
	  cout << "string_hist_nb_sel_nominal=" << string_hist_nb_sel_nominal << endl;

	  TH1D hist_nb_sel_nominal(string_hist_nb_sel_nominal.c_str(),string_hist_nb_sel_nominal.c_str(),1,-1e9,1e9);
	  hist_nb_sel_nominal.SetBinContent(1,pair_nb_sel_nominal.first);
	  hist_nb_sel_nominal.SetBinError(1,pair_nb_sel_nominal.second);

	  hist_nb_sel_nominal.Write();
	}	  
	else if (found_nominal && string_variation!="nominal") { //write the results

	  string string_hist_nb_sel_sys="hist_nb_sel_sys_";

	  string_hist_nb_sel_sys+=string_variation;
	  string_hist_nb_sel_sys+="_";
	  string_hist_nb_sel_sys+=string_category;

	  cout << "string_hist_nb_sel_sys=" << string_hist_nb_sel_sys << endl;

	  TH1D hist_nb_sel_sys(string_hist_nb_sel_sys.c_str(),string_hist_nb_sel_sys.c_str(),1,-1e9,1e9);
	  hist_nb_sel_sys.SetBinContent(1,pair_nb_sel_sys.first);
	  hist_nb_sel_sys.SetBinError(1,pair_nb_sel_sys.second);
	  
	  //=====================================================================================================================================================

	  hist_nb_sel_sys.Write();

	} //end write results
	
	//      vec_string_branch_weights.clear();
	
	//      return 0;
      } //end list of keys
      
    } //end loop on category
    
  } //end list of files
  
  return 0;
}
//=====================================================================================================================================================
//return_b_sel
pair<double,double> return_nb_sel(TTree *tree)
{
  double weight_total=0;
  
  TBranch *branch_weight_total=0;
  
  //      tree->SetBranchAddress("weight_event",&weight_event);
  //      tree->SetBranchAddress("weight_lumi",&weight_lumi);
  
  tree->SetBranchAddress("weight_total",&weight_total,&branch_weight_total);

  double nb_sel=0;
  double err_nb_sel=0;

  int nb_entries=tree->GetEntries();
  
  for (int index_entry=0;index_entry<nb_entries;index_entry++) {
    //for (int index_entry=0;index_entry<5;index_entry++) {
    
    //cout << "index_entry=" << index_entry << endl;
    
    //	tree->GetEntry(index_entry);
    
    branch_weight_total->GetEntry(index_entry);
    
    nb_sel+=weight_total;
    err_nb_sel+=weight_total*weight_total;
    
  } //end loop on entries

  err_nb_sel=sqrt(err_nb_sel);

  cout << "nb_sel=" << nb_sel << " +/- " << err_nb_sel << endl;

  return make_pair(nb_sel,err_nb_sel);
  //  exit(1);
}
//=====================================================================================================================================================
double get_err_rel_effect_yield_fully_correlated(double yield_nominal,
						 double yield_sys,
						 double err_yield_nominal,
						 double err_yield_sys)
{
  double local_err_rel_effect_yield=100.*sqrt(
					      (pow(yield_sys,2)*pow(err_yield_nominal,2)/pow(yield_nominal,4))
					      +(pow(err_yield_sys,2)/pow(yield_nominal,2))
					      -2.*yield_sys*err_yield_nominal*err_yield_sys/pow(yield_nominal,3)
					      );
  cout << "- - - - - - - - - - - - - -" << endl;
  cout << "full treatment" << endl;
  cout << "yield_nominal=" << yield_nominal << endl;
  cout << "yield_sys=" << yield_sys << endl;
  cout << "err_yield_nominal=" << err_yield_nominal << endl;
  cout << "err_yield_sys=" << err_yield_sys << endl;
  
  cout << "local_err_rel_effect_yield=" << local_err_rel_effect_yield << endl;

  return local_err_rel_effect_yield;
}
